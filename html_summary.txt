--------------------------------Flexbox

    Вместо направлений «лево» и «право» во флексбоксе используется понятие «главная ось».
    Поток флекс-элементов «течёт» вдоль главной оси от её начала к её концу.
    Поток флекс-элементов «течёт» вдоль главной оси
    По умолчанию главная ось направлена слева направо, но её можно разворачивать во всех направлениях с помощью свойства flex-direction,
    которое задаётся для флекс-контейнера. Значения свойства:
    row — значение по умолчанию, главная ось направлена слева направо.
    column — главная ось направлена сверху вниз.
    row-reverse — главная ось направлена справа налево.
    column-reverse — главная ось направлена снизу вверх.
    Флекс-элементы всегда располагаются вдоль главной оси, независимо от её направления.


    Вместо «горизонтального» выравнивания во флексбоксе используется свойство для распределения элементов вдоль главной оси — justify-content.
    Это свойство задаётся для флекс-контейнера.

    Его значением по умолчанию является flex-start. При этом значении элементы располагаются у начала главной оси.

    Чтобы элементы располагались по центру главной оси, нужно задать для justify-content значение center.


    Чтобы флекс-элементы располагались в начале главной оси, свойству justify-content нужно задать значение flex-start.
    Оно же является и значением по умолчанию.

    А значение flex-end расположит элементы в конце главной оси.

    Обратите внимание, что justify-content:
    flex-end не меняет порядок элементов, как это происходит при изменении направления оси flex-direction: row-reverse.
    Элементы просто прижимаются к концу главной оси.


    У флексбокса есть чем-то похожие значения justify-content, которые равномерно распределяют флекс-элементы вдоль главной оси:

    space-between — расстояния между соседними элементами одинаковые, между элементами и краями флекс-контейнера отступов нет.
    space-around — расстояния между соседними элементами одинаковые, между элементами и краями флекс-контейнера есть отступ,
    равный половине расстояния между соседними элементами.

    Сейчас мы добавим третьего кота и поэкспериментируем с этими значениями justify-content.
    А пока небольшой итог. Свойство justify-content управляет распределением элементов вдоль главной оси и имеет пять значений:

    значение по умолчанию flex-start,
    flex-end,
    center,
    space-between,
    space-around.


    Вместо «вертикального» выравнивания во флексбоксе используется свойство для выравнивания элементов вдоль поперечной оси — align-items.
    Это свойство задаётся для флекс-контейнера.

    Его значением по умолчанию является stretch. Именно благодаря этому значению флекс-элементы и растягиваются на всю «высоту» флекс-контейнера.
    Если флекс-элементам задана высота, то растягиваться они не будут.

    Чтобы элементы выровнялись по центру поперечной оси, нужно задать для align-items значение center.


    Ещё одно значение свойства align-items — это baseline. Если задать его контейнеру,
    то флекс-элементы будут выравниваться по базовой линии текста в них. Эта воображаемая линия проходит по нижней части букв.

    Если выровнять флекс-элементы по базовой линии, то они выстроятся так, чтобы текст в них был как бы на «одной строке».



    Что будет, если флекс-элементов в контейнере станет больше, чем может уместиться в один ряд?

    Они будут сжиматься до минимально возможной ширины.
    Даже если им задать ширину явно, механизм флексбокса может её уменьшить.
    Если они перестанут помещаться в контейнер и после уменьшения, то они выйдут за его пределы, но продолжат располагаться в один ряд.
    Это чем-то похоже на поведение ячеек в таблице.

    Такое поведение можно изменить свойством флекс-контейнера flex-wrap. По умолчанию оно имеет значение nowrap,
    то есть перенос флекс-элементов на новую строку запрещён.

    Значение wrap разрешает перенос флекс-элементов на новую строку, если они не помещаются в контейнер.



    Если перенос флекс-элементов разрешён, то ряды элементов располагаются вдоль поперечной оси.
    Первый ряд располагается в начале поперечной оси, а последний в конце. Но так работает только значение wrap.

    Если для flex-wrap задать значение wrap-reverse, то элементы будут переноситься,
    а ряды будут располагаться в обратном порядке: первый в конце поперечной оси, а последний в начале.



    Вспомним свойство justify-content, которое управляет распределением флекс-элементов вдоль главной оси.
    Есть очень похожее свойство align-content, которое управляет выравниванием рядов флекс-элементов вдоль поперечной оси. У этих свойств почти одинаковые значения:

    flex-start,
    flex-end,
    center,
    space-between,
    space-around,

    и stretch, которое есть у align-content, но нет у justify-content, и является значением по умолчанию.

    Свойство align-content связано и со свойством align-items, которое управляет выравниванием флекс-элементов вдоль поперечной оси.
    В чём разница между align-content и align-items, когда работает одно, а когда работает другое? Вот ответы:

    Если есть только один ряд флекс-элементов, то работает align-items.
    Если есть несколько рядов, то работает align-content.

    Подчеркнём, что align-content влияет на ряды, а не на отдельные элементы.



    Значение align-items влияет на отображение рядов во флекс-контейнере, если у align-content задано значение stretch. В этом мы убедились в прошлом задании.

    Есть ли похожее влияние на остальные значения align-content? Нет.

    Убедимся в этом на примере значения center, которое располагает ряды в середине поперечной оси так, что:

    отступов между соседними рядами нет (но отступы самих элементов сохраняются),
    расстояние между первым рядом и краем флекс-контейнера равно расстоянию между последним рядом и другим краем.



    Остальные четыре значения свойства align-content аналогичны значениям свойства justify-content, отличается только ось:

    flex-start располагает ряды в начале поперечной оси.
    flex-end располагает ряды в конце поперечной оси.
    space-between равномерно распределяет ряды вдоль поперечной оси, расстояния между соседними рядами одинаковые, отступов у краёв нет.
    space-around равномерно распределяет ряды вдоль поперечной оси, расстояния между соседними рядами одинаковые, отступы у краёв равны
    половине расстояния между соседними рядами.

    Напоследок небольшое резюме.

    Свойство align-content — «гибридное». Мы переводим его как «выравнивание», но оно больше похоже на «распределение», justify-content,
    от которого оно позаимствовало два значения space-between и space-around.
    Близость с «распределением» подчёркивает и отсутствие значения baseline — всё-таки свойство работает с рядами, а не с отдельными элементами.
    От «выравниваний» же, align-items и align-self, это свойство получило значение по умолчанию stretch и возможность «растягивать» ряды по высоте.



    Заметьте, что флекс-элементами внутри флекс-контейнера становятся только прямые потомки, элементы первого уровня вложенности.

    В нашем примере флекс-контейнер .post включает два флекс-элемента section и aside.
    Блоки внутри флекс-элементов ведут себя как обычно, флекс-поток их не затрагивает.


    Флекс-элемент внутри флекс-контейнера можно также сделать флекс-контейнером.

    Он будет одновременно вести себя и как флекс-элемент, то есть подчиняться правилам распределения
    и выравнивания своего родителя, и как самостоятельный флекс-контейнер.
    При этом его вложенные элементы первого уровня будут следовать только его флекс-правилам.



    Интересного эффекта можно достичь, если скомбинировать флексбокс и трюк с селектором :checked ~.
    Подробно :checked ~ разбирается в задании курса «Селекторы. Часть 3».

    Приём заключается в следующем: с помощью селектора по выделению чекбокса можно управлять порядком флекс-элементов,
    изменяя направление главной оси с помощью flex-direction. Лучше всего эффект работает, когда направление главной оси меняется с «сверху вниз» на «снизу вверх».

    При этом флекс-контейнер должен находиться в разметке на одном уровне с чекбоксом.

    Таким образом реализуется сортировка на CSS, без использования JavaScript.



    И такое свойство есть — это flex-basis. Оно задаёт базовый размер флекс-элемента или размер вдоль главной оси.
    Если flex-basis не задан или его значение равно auto, то базовый размер берётся из width или height.
    Свойство flex-basis принимает те же значения, что и width/height:
    Свойство flex-basis «сильнее» свойств width и height, и если у флекс-элемента заданы все три свойства,
    то flex-basis переопределит либо ширину, либо высоту в зависимости от направления главной оси.



    Если внутри флекс-контейнера по главной оси остаётся свободное место, то мы можем попросить флекс-элемент,
    чтобы он увеличился и занял это место. Это делается с помощью свойства flex-grow, которое можно назвать «коэффициентом флекс-жадности» флекс-элемента.

    Свойство flex-grow принимает неотрицательные числовые значения, его значение по умолчанию — 0.

    Если значение flex-grow равно нулю, то флекс-элемент «не претендует»
    на оставшееся свободное место во флекс-контейнере и не будет увеличиваться, чтобы занять это место.

    Если значение flex-grow больше нуля, то флекс-элемент будет увеличиваться, «захватывая» оставшееся свободное место.

    Получается, что базовый размер — это исходный размер флекс-элементов до применения flex-grow.



    1 шаг. Рассчитываем свободное место во флекс-контейнере:
    Свободное место = Ширина контейнера - Сумма базовых размеров элементов

    2 шаг. Считаем размер минимальной доли свободного места:
    Доля свободного места = Свободное место / Сумма flex-grow всех элементов

    3 шаг. Базовый размер каждого флекс-элемента увеличиваем на размер минимальной доли свободного места умноженной на значение flex-grow этого элемента:
    Итоговый размер = Базовый размер + (Доля свободного места * flex-grow)

    Для верхнего блока с енотами хочется задать коэффициенты 1 и 2. Но нужные размеры блоков получаются с коэффициентами 1 и 3. Давайте посчитаем:

    Свободное место = 300px - (50px * 2) = 200px
    Доля свободного места = 200px / (1 + 3) = 50px
    Итоговый размер зелёного енота = 50px + (50px * 1) = 100px
    Итоговый размер коричневого енота = 50px + (50px * 3) = 200px
    Но если задать флекс-элементам нулевой базовый размер, свободное место будет занимать всю ширину флекс-контейнера, и коэффициенты жадности будут другими.

    !Использовать flex-basis: 0 и flex-grow для точного управления относительными размерами не стоит. Лучше использовать базовый размер в процентах.

    Тонкость. На размер оставшегося свободного места влияет не только flex-basis, но и рамки, и отступы. Если flex-basis явно задано нулевое значение,
    то min-width на размер свободного места влиять не будет, так как ограничения размеров к флекс-элементам применяются уже после перераспределения свободного места.



    Если сумма базовых размеров флекс-элементов больше, чем размер флекс-контейнера, то возникает отрицательное пространство.

    Механизм перераспределения работает не только для свободного места, но и для отрицательного пространства.
    Флекс-элементы умеют распределять отрицательное пространство между собой и сжиматься.

    За уменьшение флекс-элементов отвечает свойство flex-shrink, которое можно назвать «коэффициентом сжатия».

    Свойство flex-shrink принимает неотрицательные числовые значения, его значение по умолчанию — 1.

    Если значение flex-shrink больше нуля, то флекс-элемент будет уменьшаться, «впитывая» часть отрицательного пространства, если оно существует.
    Если значение flex-shrink равно нулю, то флекс-элемент уменьшаться не будет.

    Флекс-элементы стараются быть максимально «гибкими» и не выпадать из своего контейнера,
    поэтому у flex-shrink значение по умолчанию равно 1. Но если задавать нулевые значения для коэффициента сжатия, то выпадения элементов добиться можно.



    1 шаг. Рассчитываем отрицательное пространство (ОП) во флекс-контейнере:
    ОП = Ширина контейнера - Сумма базовых размеров элементов

    2 шаг. Находим сумму произведений базовых размеров (СПБР) элементов на их коэффициенты сжатия:
    СПБР = (Базовый размер1 * flex-shrink1) + (Базовый размер2 * flex-shrink2) + … + (Базовый размерn * flex-shrinkn)

    3 шаг. Для каждого элемента считаем «нормированный коэффициент сжатия» (НКС),
    для чего произведение базового размера элемента на его коэффициент сжатия делим на СПБР:
    НКС = (Базовый размер * flex-shrink) / СПБР

    4 шаг. Базовый размер элемента уменьшаем на часть ОП пропорциональную НКС элемента:

    Итоговый размер = Базовый размер - (НКС * ОП)
    Получается, что доля отрицательного пространства, которую «впитает» элемент, зависит от двух факторов:

    соотношения коэффициента сжатия элемента с коэффициентами других элементов,
    соотношения базового размера элемента с базовыми размерами других элементов.
    Именно поэтому в формулах присутствуют нормировки. А теперь снова попробуйте подобрать коэффициенты сжатия.



    Есть несколько тонкостей, касающихся сжатия флекс-элементов:

    элементы сжимаются в пределах своих базовых размеров, внутренние отступы и рамки не сжимаются;
    «ограничительные» свойства, такие как min-width, применяются к элементам после этапа перераспределения свободного места или отрицательного пространства.

    И эти тонкости могут приводить к неожиданным эффектам, когда элементы выпадают из флекс-контейнера.



    С помощью сокращённого свойства flex можно одновременно задать коэффициенты растягивания, сжатия и базовый размер флекс-элемента.

    Свойство flex состоит из трёх компонентов, которые пишутся через пробел в следующем порядке: flex-grow, flex-shrink и flex-basis. В примере ниже два правила аналогичны:

    .flex-item {
        flex: 1 2 300px;
    }

    .flex-item {
        flex-grow: 1;
        flex-shrink: 2;
        flex-basis: 300px;
    }
    Ещё у свойства flex есть особые значения: initial, auto, none. Также второй и третий компоненты необязательны. Ниже показаны различные значения свойства и их расшифровки.

    flex: initial; -> flex: 0 1 auto;
    flex: auto;    -> flex: 1 1 auto;
    flex: none;    -> flex: 0 0 auto;
    flex: 1 0;     -> flex: 1 0 0%;
    flex: 1;       -> flex: 1 1 0%;
    В некоторых браузерах неполные или особенные значения свойства flex интерпретируются с ошибками. Поэтому лучше задавать все три компоненты в значении этого свойства.



    Во всех примерах, рассмотренных раньше, флекс-контейнер был однострочным, ведь перенос флекс-элементов на новую строку по умолчанию запрещён — работает flex-wrap: nowrap;.

    А как будут растягиваться и сжиматься элементы в многострочном контейнере, с flex-wrap: wrap;?

    В таком контейнере свойство flex-shrink будет работать как обычно, но необходимость в нём будет возникать намного реже.
    Ведь при нехватке места в строке флекс-элементы будут переноситься на новую строку.

    Но если появятся флекс-элементы, базовый размер которых больше размера флекс-контейнера, то такие элементы будут сжиматься и занимать целую строку.
    Наверное, это единственный случай, когда flex-shrink делает что-то полезное в многострочном контейнере.


-------заголовки на флексе

    <!DOCTYPE html>
    <html lang="ru">
    <head>
        <meta charset="utf-8">
        <title>Заголовок с описанием, часть 2</title>
        <base href="/assets/course113/">
        <link href="style.css" rel="stylesheet">
        <link href="course.css" rel="stylesheet">
    </head>
    <body class="subtle">
        <section class="card">
            <h1 class="card-title">
                <span class="card-title-main">Кекс против флекса</span>
                <span class="card-title-note">история взросления</span>
            </h1>
            <p>За свою долгую карьеру фронтенд-разработчика Кекс видал много непонятных решений...</p>
        </section>
        <section class="card">
            <h1 class="card-title">
                <span class="card-title-main">Кекс любит флекс</span>
                <span class="card-title-note">история успеха</span>
            </h1>
            <p>Изучение флексбокса далось с трудом, но те возможности, которые появились у Кекса с этой «гибкой» раскладкой...</p>
        </section>
    </body>
    </html>

    .card {
        margin-bottom: 20px;
        line-height: 1.3;
    }

    .card-title {
        display: flex;
        margin-top: 0;
        align-items: flex-end;
    }

    .card-title span {
        background-color: #c8dcff;
        border: 1px solid #999999;
    }

    .card-title-main {
        flex-grow: 1;
    }



    Ещё один случай, когда может пригодиться флексбокс — поля ввода с динамической шириной. Требования к ним такие:

    На одной строке с полем могут находиться другие элементы: кнопки, ссылки, подписи.
    Размер дополнительных элементов не определён, он зависит от их содержимого.
    При этом поле должно растягиваться на всё оставшееся в родительском контейнере место.
    И изменять ширину при изменении размеров контейнера.
    Решить эту задачу можно только при помощи флексбокса.
    Превратим контейнер поля ввода во флекс-контейнер, все элементы внутри него превратятся во флекс-элементы,
    базовый размер которых будет зависеть от их содержания — flex-basis: auto;. И останется только задать ненулевой коэффициент растягивания полям ввода.

    В широком контейнере всё будет работать отлично. Проблемы могут появиться в слишком узких контейнерах:
    по умолчанию поля ввода не будут сжиматься после определённой ширины, что приведёт к выпаданию текста из остальных элементов.

    Чтобы справиться с этими проблемами, надо задать всем элементам кроме полей ввода нулевой коэффициент сжатия,
    а самим полям ввода явно прописать минимальную ширину.

















--------------------------------Использование градиентов

    Одна из интересных задач вёрстки — как сверстать тянущиеся колонки одинаковой высоты без использования таблиц?
    Проблема эта связана с особенностями поведения блочной модели и проиллюстрирована на картинках ниже:

    Для решения этой задачи существует несколько приёмов, которые описаны в этой статье на английском (https://css-tricks.com/fluid-width-equal-height-columns/).
    Кстати, картинки тоже взяты оттуда.

    Давайте применим приём с использованием градиентов с резкими переходами, которые имитируют тянущиеся колонки.
    Фон с такими градиентами обычно размещают в контейнере колонок. Пропорции градиентов подбирают такими же, как и пропорции колонок, чтобы они тянулись одинаково.


    -----красивый цветок на градиентах

    .leaf-top-left {
          background-image: linear-gradient(-45deg, #f00000 30px, #000000 30px, #000000 40px, #ff0000 40px, #ff0000 70px, #000000 70px);
      }

      .leaf-top-right {
          /* цвета: #00ff00, #000000, #00ff00, #000000 */
          background-image: linear-gradient(45deg, #00ff00 30px, #000000 30px, #000000 40px, #00ff00 40px, #00ff00 70px, #000000 70px);
      }

      .leaf-bottom-right {
          /* цвета: #ffff00, #000000, #ffff00, #000000 */
          background-image: linear-gradient(135deg, #ffff00 30px, #000000 30px, #000000 40px, #ffff00 40px, #ffff00 70px, #000000 70px);
      }

      .leaf-bottom-left {
          /* цвета: #ff00ff, #000000, #ff00ff, #000000 */
          background-image: linear-gradient(225deg, #ff00ff 30px, #000000 30px, #000000 40px, #ff00ff 40px, #ff00ff 70px, #000000 70px);
      }

      .leaf-top-left, .leaf-bottom-right {
          border-radius: 0 50%;
      }

      .leaf-top-right, .leaf-bottom-left {
          border-radius: 50% 0;
      }

      .leaf {
          float: left;
          width: 150px;
          height: 150px;
          background-color: #dfdfdf;
      }

      .flower {
          width: 300px;
          margin: 70px auto;
      }

      html,
      body {
          margin: 0;
          padding: 0;
      }

--------------круговое меню

    <!DOCTYPE html>
    <html lang="ru">
    <head>
        <title>Круговое меню, финал</title>
        <meta charset="utf-8">
        <base href="/assets/icons/">
    </head>
    <body>
        <nav class="circle-menu">
            <div class="center"></div>
            <ul>
                <li><a href="#">monitor</a></li>
                <li><a href="#">aperture</a></li>
                <li><a href="#">stuff</a></li>
                <li><a href="#">stuff</a></li>
                <li><a href="#">stuff</a></li>
                <li><a href="#">stuff</a></li>
            </ul>
        </nav>
    </body>
    </html>

    html,
    body {
        margin: 0;
        padding: 0;
        background: #f5f5f5;
    }

    .circle-menu {
        position: relative;
        width: 400px;
        height: 400px;
        margin: 50px auto;
        background: white;
        box-shadow: 0 0 3px #cccccc;
    }

    .circle-menu ul {
        position: absolute;
        width: 300px;
        height: 300px;
        margin: 50px;
        padding: 0;
        list-style: none;
        border-radius: 50%;
        overflow: hidden;
    }

    .circle-menu .center{
        position: absolute;
        top: 195px;
        left: 195px;
        z-index: 1000;
        border: 5px solid #34495e;
        border-radius: 50%;
        box-shadow: 0 0 3px #cccccc;
    }

    .circle-menu li {
        position: absolute;
        top: -10px;
        left: -10px;
        width: 160px;
        height: 160px;
        transform-origin: 100% 100%;
        overflow: hidden;
    }

    .circle-menu li:nth-child(1) {
        transform: rotate(0deg) skew(30deg);
    }

    .circle-menu li:nth-child(2) {
         transform: rotate(60deg) skew(30deg);
    }

    .circle-menu li:nth-child(3) {
         transform: rotate(120deg) skew(30deg);
    }


    .circle-menu li:nth-child(4) {
         transform: rotate(180deg) skew(30deg);
    }


    .circle-menu li:nth-child(5) {
         transform: rotate(240deg) skew(30deg);
    }


    .circle-menu li:nth-child(6) {
         transform: rotate(300deg) skew(30deg);
    }
    .circle-menu li a {
        display: block;
        width: 160px;
        height: 160px;
        margin-top: 40px;
        margin-left: 40px;
        font-size: 0;
        background: rgba(241, 196, 15, 0.5) url("monitor-4x.png") no-repeat 50% 40%;
        transition: background-color 0.5s;
        transform: skew(-30deg) rotate(-60deg);
    }

    .circle-menu li:nth-child(even) a {
        background-color: rgba(241, 196, 15, 0.75);
    }

    .circle-menu li a:hover {
        background-color: rgba(241, 196, 15, 1);
    }

    /* Иконки */

    .circle-menu li:nth-child(2) a {
        background-image: url("aperture-4x.png");
    }

    .circle-menu li:nth-child(3) a {
        background-image: url("audio-4x.png");
    }

    .circle-menu li:nth-child(4) a {
        background-image: url("battery-empty-4x.png");
    }

    .circle-menu li:nth-child(5) a {
        background-image: url("bluetooth-4x.png");
    }

    .circle-menu li:nth-child(6) a {
        background-image: url("browser-4x.png");
    }





--------------------------------Рамки фоны и украшательство

    Ещё два значения свойства background-size — это contain и cover.

    Значение contain работает так:

    пропорции изображения сохраняются;
    изображению задаются максимально возможные размеры, при которых оно и по ширине, и по высоте полностью помещается в границы фона;
    изображение может не закрывать всю фоновую область блока, если пропорции изображения и блока разные.
    Значение cover работает иначе:

    пропорции изображения сохраняются;
    изображению задаются минимально возможные размеры, при которых оно закроет всю фоновую область блока;
    если пропорции изображения и блока разные, то часть изображения обрезается.



    Ещё одно фоновое свойство — background-origin.
    Оно задаёт расположение и размеры области отображения фонового изображения и принимает три значения: padding-box, border-box и content-box.

    Значение по умолчанию — padding-box. При этом значении область отображения фонового изображения соответствует внутренней области блока, не включая рамки.

    При content-box область отображения соответствует только области содержимого, не включая рамки и внутренние отступы.

    При border-box область отображения соответствует полному размеру блока, включая и рамки.
    Фоновое изображение начинается от внешнего края блока и закрывается рамками, если они заданы.



    Свойство background-clip управляет тем, как обрезается фон. Причём обрезаются не только фоновые изображения, но и фоновый цвет.
    Значения свойства такие же, как у background-origin: padding-box, border-box и content-box.

    Значение border-box задано по умолчанию, при этом фоновое изображение совсем не обрезается.

    Значение padding-box обрежет фон по внутреннему краю области рамки.

    Значение content-box обрежет фон по краю области содержимого.



    Можно задать блоку несколько фоновых изображений одновременно.
    Для этого пути к изображениям в свойстве background-image или background перечисляются через запятую:

    background-image: url("image-1.png"), url("image-2.png");
    При этом выше будет то изображение, которое находится раньше в списке: image-1.png в примере будет выше image-2.png.

    Значения других свойств для множественных фоновых изображений тоже задаются через запятую.
    Порядок значений должен соответствовать порядку фоновых картинок. Например:

    /* для первой картинки масштабирование contain, для второй — 100px */
    background-size: contain, 100px;

    /* для первой картинки позиционирование top, для второй — 100% */
    background-position: top, 100%;


    Интересная возможность background-position, о которой мы раньше не рассказывали —
    расположение фона можно задавать относительно любого угла блока, а не только от левого верхнего.

    Чтобы указать от какой стороны отсчитывать расположение фона, нужно перед значением координат задать ключевые слова: top, right, bottom или left. Например:

    /* по умолчанию координаты задаются для левого верхнего угла */
    background-position: 10px 50px; /* слева 10px, сверху 50px */

    background-position: right 30px bottom 60px; /* справа 30px, снизу 60px */
    background-position: left 50px bottom 10px; /* слева 50px, снизу 10px */
    background-position: right 40px top 30px; /* справа 40px, сверху 30px */
    Поддержка данных значений свойства background-position в современных браузерах практически полная.



    Два интересных, но малоизвестных значения привычного свойства background-repeat, которое задаёт повторение фона, — это round и space.

    Значение свойства по умолчанию background-repeat: repeat просто повторяет фоновую картинку по всей ширине и высоте блока.
    Если части повторяющейся картинки не помещаются в ширину блока, то они просто обрезаются.

    Если задать значение background-repeat: round, то повторяющиеся картинки по краям блока обрезаться не будут,
    а равномерно растянутся или сожмутся по всей ширине, чтобы занять оставшееся пространство.

    Кстати, background-repeat принимает в качестве значения два аргумента: режим повторения по горизонтали и по вертикали.
    Если передать один параметр, то он применится к обоим направлениям. Например:

    /* повторение фона repeat по горизонтали и вертикали */
    background-repeat: repeat;

    /* повторение фона round по горизонтали и repeat по вертикали */
    background-repeat: round repeat;
    Давайте опробуем режим повторения round на практике.


    Режим повторения фона background-repeat: space похож на round, при нём части картинки тоже не обрезаются.
    Отличие в том, что повторяющиеся фоновые картинки не сжимаются или растягиваются,
    а для компенсации ширины блока между ними добавляется пустое пространство



    Полезное, но редко используемое свойство — внешняя рамка или outline.

    Синтаксис outline схож с border. Но внешней рамке нельзя задать параметры отдельных сторон. Пример:

    /* сплошная чёрная рамка толщиной 10px */
    outline: 10px solid black;
    Это сокращённый синтаксис свойства outline. Есть и отдельные свойства:

    outline-width: 10px;  /* толщина */
    outline-style: solid; /* стиль */
    outline-color: black; /* цвет */
    Внешняя рамка всегда отображается снаружи элемента, не влияет на его размер и не занимает места, то есть отображается над другими элементами.

    C помощью свойства outline-offset можно изменять расположение рамки.
    Положительное значение отодвигает рамку от внешнего края элемента, а отрицательное «втягивает» внутрь.

    У outline-style те же значения, что и у border-style.
    Кстати, есть интересные типы рамок ridge и groove, они создают объёмные рамки.


    Закруглять углы элементов можно с помощью свойства border-radius.

    Вы можете закруглять отдельные углы с помощью свойств: border-top-left-radius, border-top-right-radius, border-bottom-right-radius и border-bottom-left-radius.

    А ещё можно задавать разные горизонтальные и вертикальные радиусы скругления.
    Для этого нужно написать два значения через пробел в свойстве скругления угла. Первое значение задаёт радиус по горизонтали, второе — по вертикали:

    /* горизонтальный радиус 30px, вертикальный 15px */
    border-top-right-radius: 30px 15px;
    Разные горизонтальные и вертикальные радиусы можно задавать и в свойстве border-radius. Для этого нужно использовать /, например:

    /* горизонтальный радиус всех углов 10px, вертикальный 5px */
    border-radius: 10px / 5px;

    /* разные горизонтальные и вертикальные радиусы у каждого угла */
    border-radius: 10px 20px 30px 40px / 5px 15px 25px 35px;



    Мы подошли к обширной и интересной теме, в которой рамки и фоновые изображения встречаются.

    Итак, семейство свойств border-image задаёт фоновое изображение для рамки блока.
    Поддержка данного семейства свойств в современных браузерах довольно неплохая.

    Свойство border-image-source задаёт путь к изображению рамки. По умолчанию картинкой заполнятся только углы рамки.
    В следующих заданиях мы разберём, как можно управлять отображением рамки.

    В качестве изображения для рамки используем вот такую картинку:

    Синтаксис свойства такой же, как у background-image, то есть:

    border-image-source: url("image.jpg");


    Давайте разберёмся, как работает механизм «нарезки» фонового изображения для рамки.

    Каждая рамка имеет 9 областей: 4 угла, 4 стороны и центральную область.
    Для заполнения этих областей браузер должен нарезать картинку для рамки на 9 частей.
    Когда браузер не знает, как это сделать, он просто размещает картинку по углам — мы видели это в предыдущем задании.

    Свойство border-image-slice задаёт отступы от краёв картинки до четырёх линий,
    которые «разрезают» её на части, как на схеме справа. Если эти отступы небольшие, то получается «нарезка» из 9 частей,
    которые затем размещаются в соответствующих областях рамки.

    Но если отступы слишком большие (больше половины картинки), то браузер не может получить 9 частей и располагает то, что отрезалось по углам.

    Значение свойства можно задавать числом без единицы измерения (оно обычно обозначает пиксели) или в процентах (относительно размера самой картинки). Пример:

    border-image-slice: 60;
    border-image-slice: 10%;


    Сравните две картинки:
    Для нарезки первой из них можно было задать одинаковые отступы линий разреза — 50px.
    Для второй картинки этого явно недостаточно — она менее симметрична.

    С помощью border-image-slice можно задавать разные отступы линий разреза.
    Для этого нужно задавать значения через пробел в порядке: верх, право, низ, лево. Пример:

    border-image-slice: 10 20 30 40;
    Средняя часть картинки обычно не используется. Но если в значение свойства добавить ключевое слово fill,
    то средняя часть картинки будет отображаться в средней области рамки: она закроет собой фон блока, но не закроет содержимое. Пример:

    border-image-slice: 10 20 30 40 fill;


    Свойство border-image-repeat задаёт способ заполнения фоном боковых сторон рамки (зелёные области на рисунке).
    У свойства четыре значения: stretch, repeat, space и round.
    Значение по умолчанию — stretch. При этом значении фоновые картинки растягиваются на всю длину боковых сторон.
    Если задано значение repeat, то фоновые картинки будут повторяться. При этом они могут обрезаться.
    Можно устанавливать режим заполнения отдельно для горизонтальных и вертикальных сторон рамки.

    Например:
    /* все стороны рамки заполняются в режиме stretch */
    border-image-repeat: stretch;
    /* горизонтальные стороны — режим repeat, вертикальные — stretch */
    border-image-repeat: repeat stretch;
    Давайте посмотрим, в чём различие этих двух вариантов.

    Значение round свойства border-image-repeat тоже устанавливает режим заполнения стороны рамки повторяющимися боковыми участками картинки.
    Но, в отличие от repeat, если в ширину стороны не вмещается целое число повторящихся кусочков, крайние части не обрезаются.
    Кусочки при этом равномерно растягиваются так, чтобы все они стали одного размера и заняли оставшееся место стороны рамки.

    Согласно спецификации при заданном значении space алгоритм похож на round, только для компенсации оставшегося
    места кусочки картинки не растягиваются, а остаются прежней ширины, при этом между кусочками появляется дополнительное свободное пространство.


    --------треугольник при помощи рамки

    .arrow-bottom {
        border: 100px solid #ffffff;
        border-top: 100px solid #0074d9;
        border-bottom: 0px;
        border-left: 100px solid transparent;
        border-right: 100px solid transparent;
    }

    --------прямая стрелка

    .arrow-right-long {
        position: relative;
        width: 200px;
        height: 30px;
        margin: 150px auto;
        background: #0074d9;
    }

    .arrow-right-long::after {
        content: "";
        position: absolute;
        top: -25px;
        right: -30px;
        border: 40px solid #ffffff;
        border-right-width: 0;
        border-top-color: transparent;
        border-bottom-color: transparent;
        border-left-color: #0074d9;
    }

    --------круглая стрелка

        .arrow-round {
        position: relative;
        width: 200px;
        height: 200px;
        margin: 100px auto;
        border: 50px solid #0074d9;
        border-radius: 50%;
        border-right-color: transparent;
    }

    .arrow-round::after {
        content: "";
        position: absolute;
        border: 100px solid #ffffff;
        border-bottom-color: #0074d9;
        top: -45px;
        left: 130px;
        border-top-width: 0px;
        border-right-width: 0px;
        border-left-color: transparent;
    }




--------------------------------больше про формы


    В качестве кнопки отправки формы можно использовать изображение.

    Для этого у тега input нужно указать тип image.

    Аналогично обычным изображениям на сайте у кнопки-изображения есть еще два атрибута:

    src	адрес изображения
    alt	альтернативный текст, отображаемый в том случае, если изображение не загружено
    Кнопка-изображение работает аналогично кнопке submit, но на сервер дополнительно передаются координаты точки, по которой был произведен щелчок.



    В предыдущих заданиях мы уже использовали поля с типами date и time, но существуют и другие типы полей для ввода дат:

    datetime	выбор даты с указанием времени (c учетом временной зоны)
    datetime-local	выбор даты с указанием времени (без учета временной зоны)
    week	выбор порядкового номера недели в году и года
    month	выбор месяца и года
    Используем поле для выбора месяца в нашей форме. А для выбора числа используем уже знакомый тип number.


    В нашей форме обязательно должна быть возможность выбрать количество дней, на которое будет осуществляться бронирование. Для этой цели подходит тип поля range.
    Такое поле выглядит как шкала с ползунком и позволяет выбрать число из некоторого интервала значений.0
    Пример записи:
    <input type="range" min="1" max="10">
    Атрибуты min и max устанавливают нижнюю и верхнюю границу допустимых значений. А атрибут step устанавливает величину шага изменения значения.


    Чтобы видеть количество дней в брони, используем новый HTML5-тег <output>.
    Тег <output> представляет собой область, куда выводятся какие-либо результаты вычислений, обычно полученные при помощи JavaScript.
    Пример записи:
    <output name="sum">[значение по умолчанию]</output>

    Цель 1 Создайте элемент output и установите в атрибут name значение daysoutput.
    Цель 2 Тегу form добавьте атрибут oninput со значением  daysoutput.value=dayscount.value.


----------Группировка полей формы
    Когда формы становятся очень большими, возникает потребность зрительно отделить одни поля от других. Для группировки полей используется тег fieldset.

    Пример:

    <fieldset>
      <input type="text">
      <input type="text">
      <input type="text">
    </fieldset>
    <fieldset>
      <textarea></textarea>
    </fieldset>
    По умолчанию браузеры отображают результат в виде рамки вокруг этой группы полей, но при помощи CSS можно изменить его внешний вид.

    Также для каждой группы можно добавить её заголовок. Для этого внутрь тега fieldset надо поместить тег legend:

    <fieldset>
      <legend>Заголовок группы</legend>
      <input type="text">
    </fieldset>



    Новый тип поля tel появился в HTML5 и отвечает за ввод телефонных номеров.
    Также воспользуемся атрибутом pattern, чтобы исключить ошибки при заполнении формы.


    В HTML5 добавлены два типа полей email и url, предназначенные для ввода электронной почты и адреса сайта.
    Особенностью этих полей является то, что они автоматически проверяют формат введённых данных.

    Пример записи:

    <input type="email">
    <input type="url">
    Внешне эти поля не отличаются от обычных текстовых полей, но обладают важной особенностью, которая очень полезна на мобильных устройствах.

    Когда вы начинаете заполнять такое поле на мобильнике, там автоматически переключается раскладка клавиатуры. Например, для email
    отобразятся латинские символы, цифры, знак @ и некоторые другие. Посмотрите на скриншоты:



    Иногда возникают ситуации, когда какие-то поля требуется сделать недоступными для редактирования.

    Есть два способа: использование атрибута readonly и использование атрибута disabled

    Пример записи:

    <input type="text" readonly>
    <input type="text" disabled>
    В чем же отличие между ними?

    Атрибут readonly не дает пользователю изменять поле (вводить новый текст, модифицировать существующий).
    Введенное значение можно выделить и скопировать. Данные из этого поля отправляются на сервер.

    Атрибут disabled не дает пользователю изменять поле (вводить новый текст, модифицировать существующий).
    Нельзя поставить фокус в это поле, введенное значение нельзя выделять и копировать. Данные из этого поля НЕ отправляются на сервер.




--------Альтернативный способ задания кнопок

    Помимо тега <input> для добавления кнопок можно использовать тег <button>. Он расширяет возможности создания кнопок.

    Внутри тега <button> можно размещать любые HTML-элементы, в том числе изображения. Например:

    <button>Календарь <img src="/assets/course74/calend.png" alt=""></button>
    В данном случае кнопка будет выглядеть примерно вот так:

    Если в атрибуте type тега <button> указать значение submit или reset, то кнопка будет отправлять данные на сервер или сбрасывать введенные значения.

    По умолчанию значение атрибута type – submit.

    То есть внутри формы кнопка <button> по нажатию отправит форму на сервер.

    Значениями атрибута type также могут быть button и reset.

    Кнопка button со значением type="reset" аналогично input type="reset" сбрасывает значения полей формы к изначальным.

    А вот значение type="button" избавит кнопку от всей изначальной фунциональности. То есть кнопка просто будет выглядеть как кнопка, но ничего по умолчанию не делать.
    Это удобно, если вы хотите сами добавить кнопке дополнительное действие с помощью JavaScript.





--------------------------------логическое разделение элементов в HTML5

    С шапками, подвалами и основным содержанием разобрались. Теперь перейдём к остальным разделам сайта.

    Раньше почти все разделы верстались на дивах. Но в HTML5 добавили сразу два новых тега для разметки разделов:

    <section> — смысловой или логический раздел документа;
    <article> — самостоятельный и независимый раздел документа.
    Чтобы не было путаницы, разберём где и когда использовать разные контейнеры:

    <div> — контейнер общего назначения, не обязательно смысловой. Дивы используются для разметки мелких блоков, создания сетки и декоративных эффектов.
    <section> — более крупный логический контейнер, объединяющий содержание по смыслу. Например, блок «О компании», список товаров, раздел личной информации
    в профиле и так далее.
    <article> — самостоятельный, цельный и независимый раздел документа. Этот раздел можно в неизменном виде использовать в различных местах, в том числе и на
    других сайтах. Примеры: статья, пост в блоге, сообщение на форуме и так далее.
    В этом задании мы сверстаем блок «Обо мне» как независимый раздел, который можно будет использовать в разных местах сайта. А список постов — это логический
    раздел, группирующий последние посты, поэтому для него используем <section>.


    В HTML5 добавили специальный элемент для навигационных блоков — тег <nav>. Так что теперь меню и блоки ссылок лучше оборачивать не в дивы, а в навы.

    В остальном же для меню ничего не изменилось. Это был список ссылок внутри дива, а стал список ссылок внутри нава.


    ехнически подключение веб-шрифтов производится с помощью CSS-правила @font-face. Читается как «эт-правило font-face». Вот пример:

    @font-face {
        font-family: "Roboto";
        src:
            local("Roboto Regular"),
            url("/assets/course73/roboto.woff") format("woff");
    }
    В этом правиле вы указываете название шрифта, которое будете использовать в font-family и источники, из которых браузер сможет загрузить шрифт.
    Обычно сначала указывают название шрифта в системе, чтобы браузер попытался найти его локально, а затем указывают адрес файла шрифта в интернете.

    Более подробно о технических тонкостях подключения шрифтов можно прочитать в серии статей на webfont.ru: первая часть и вторая часть.

    Получается, что можно хранить шрифты и подключать их со своего сервера. Это особенно полезно, когда шрифт очень редкий и его нет ни в одном из шрифтовых сервисов.
    В этом случае поступают так:

    Берут файл шрифта (например, .ttf) и конвертируют в веб-формат в сервисе наподобие Font Squirrel (для кириллических шрифтов надо указать
    дополнительные параметры конвертации).

    Затем сконвертированные файлы шрифта размещают у себя на сервере.
    И подключают шрифт с помощью @font-face.
    Сейчас мы подключим шрифт, который расположен на сервере htmlacademy. Мы уже сконвертировали шрифт в веб-формат.


    В HTML5 добавили специальный тег для обозначения даты и времени — <time>. У этого тега есть атрибут datetime — для указания даты в машиночитаемом формате ISO 8601.

    С помощью <time> можно описывать даты одновременно и для человека, и для машины, например:

    <time datetime="2014-04-20">Вчера</time> мы готовили курс к публикации.
    Браузер отображает только содержимое тега, а содержимое datetime не отображается. Человек увидит только слово «вчера»,
     а машина прочитает атрибут и получит дату в нужном ей формате. И все довольны.


     Теперь, когда шаблон поста готов, можно добавить в блог еще несколько коротких записей. А начнём с фотопоста.

     Один из новых тегов — это <figure>.

     Вспомните в книжках или учебниках изображения-выноски с подписями. Вот это и есть аналог <figure>.
     Цельный и независимый блок содержания. Внутри этого тега размещают демонстрационный материал: изображения, схемы, куски кода и так далее.

     Обычно каждый такой материал сопровождает разъясняющий комментарий или «легенда». Для обозначения этого комментария
     и предназначен ещё один новый тег — <figcaption>, который размещается первым или последним элементом внутри <figure>. Пример:

     <figure>
         схема,
         график,
         диаграмма
         и так далее
         <figcaption>Легенда</figcaption>
     </figure>
     Мы используем этот тег для более прозаичных целей.


     В HTML с самого начала было очень просто вставлять изображения, но очень сложно видео и аудио. В HTML5 эту проблему попытались решить, добавив специальные теги.

    Для вставки видео предназначен тег <video>. Его основные атрибуты:

    width и height	задают ширину и высоту видео
    controls	пустой атрибут, при наличии которого отображается панель управления видео
    preload	задаёт режим предзагрузки видео, имеет 3 возможных значения:
    none — не загружать ничего;
    metadata — загрузить служебную мета-информацию (длительность, первый кадр и т.д.);
    auto — можно загрузить всё видео.
    значение по умолчанию зависит от браузера
    src	задаёт адрес видеофайла
    autoplay	пустой атрибут, при наличии которого воспроизведение видео начинается автоматически
    poster	задаёт адрес картинки-обложки, которая отображается, когда видео еще не загрузилось или не воспроизводится



    Работа с аудио в HTML5 очень похожа на работу с видео, только у тега для аудио чуть меньше параметров.

    Для вставки звука предназначен тег <audio>. Его основные атрибуты:

    controls	пустой атрибут, при наличии которого отображается панель управления проигрывателем
    preload	задаёт режим предзагрузки аудио, имеет 3 возможных значения:
    none — не загружать ничего;
    metadata — загрузить служебную мета-информацию;
    auto — можно загрузить весь файл.
    значение по умолчанию зависит от браузера
    src	задаёт адрес аудиофайла
    autoplay	пустой атрибут, при наличии которого воспроизведение звука начинается автоматически

-------пример правильного использования хтмл 5 тегов

    <body>
      <header class="page-header">
        <div class="logo">
          <img src="/assets/course73/logo.svg" width="90" height="90">
        </div>
        <nav class="main-menu">
          <ul>
            <li><a href="#home">Главная</a></li>
            <li><a href="#blog">Посты</a></li>
            <li><a href="#me">Обо мне</a></li>
        </ul>
        </nav>
      </header>
        <main>
          <article class="blog-entry">
            <aside class="video-preview">
              <img src="/assets/course73/preview.jpg" alt="Видео превью">
            </aside>
            <section class="idea">
              <h1>Размышления о жизни</h1>
              <p>Существует много вещей, которые безразличны собакам, но кошки от них без ума.</p>
              <p>К примеру, любимое место кота — это клавиатура компьютера. Собака не будет постоянно спать на клавиатуре.</p>
            </section>
        </article>
            <section class="photos">
                <figure class="slides">
                    <img src="/assets/course73/keks-1.jpg" alt="keks-1">
                    <img src="/assets/course73/keks-2.jpg" alt="keks-2">
                    <img src="/assets/course73/keks-3.jpg" alt="keks-3">
                    <img src="/assets/course73/keks-4.jpg" alt="keks-4">
                    <img src="/assets/course73/keks-5.jpg" alt="keks-5">
                </figure>
            </section>
        </main>
        <footer class="page-footer">
            <footer class="info">
                <img src="/assets/course73/keks.jpg" width="50" alt="keks">
                     Кекс, keks@htmlacademy.ru
            </footer>
            <footer class="copyright">
                © 2008—2014 Cat Energy
            </footer>
        </footer>
    </body>


--------------------------------верстка мелких элементов

    <!DOCTYPE html>
    <html lang="ru">
        <head>
            <meta charset="utf-8">
            <title>Комментарии, шаг 5</title>
            <link href="//fonts.googleapis.com/css?family=PT+Sans:400,700&subset=cyrillic" rel="stylesheet" type="text/css">
        </head>
        <body>
            <div class="comment">
                <div class="comment-avatar"></div>
                <div class="comment-author">Дима Дивов</div>
                <div class="comment-text">
                    Верстать сайты надо только на дивах!
                    <div class="comment-date">16.09.2013</div>
                </div>
                <a href="#reply" title="Ответить" class="comment-reply"></a>
            </div>
            <div class="comment">
                <div class="comment-avatar"></div>
                <div class="comment-author">Степан Спанов</div>
                <div class="comment-text">
                    Не согласен, лучше спаны.
                    <div class="comment-date">17.09.2013</div>
                </div>
                <a href="#reply" title="Ответить" class="comment-reply"></a>
            </div>
        </body>
    </html>


    body {
        font-family: "PT Sans", sans-serif;
        font-size: 14px;
        color: #777777;
    }

    .comment {
        position: relative;
        margin-top: 30px;
        margin-right: 20px;
        margin-left: 50px;
    }

    .comment-avatar {
        position: absolute;
        top: 0px;
        left: -40px;
        width: 70px;
        height: 70px;
        background: #7f8c8c url("/assets/course14/avatar.png") no-repeat 50% 50%;
    }

    .comment-author {
        margin-bottom: 5px;
        padding-left: 45px;
        padding-right: 20px;
        font-size: 16px;
        font-weight: bold;
    }

    .comment-text {
        padding: 12px;
        padding-left: 45px;
        background-color: #f8f8f8;
        border-bottom: 5px solid #e5e6e6;
    }

    .comment-date {
        margin-top: 5px;
        font-size: 12px;
        color: #bdc3c7;
    }

    .comment-reply {
        position: absolute;
        top: 0;
        right: 0;
        width: 15px;
        height: 15px;
        background: url("/assets/course14/reply.png") no-repeat 0 0;
    }

--------------------------------float и выпадание из потока

    Про выпадание элементов из потока при абсолютном и фиксированном позиционировании мы поговорим в курсе «Позиционирование».
    А сейчас рассмотрим выпадание при флоатах.

    Зафлоаченные элементы выпадают из потока, но лишь частично:

    Блочные элементы, которые идут в коде после зафлоаченного блока, перестают его замечать. Они подтягиваются вверх и занимают его место, как будто его и нет.
    Строчные же элементы, расположенные в коде после зафлоаченного блока, начинают обтекать его со свободной стороны.
    Ещё раз: для блочных элементов флоатные не существуют, но текст внутри блоков флоатные обтекает.

    Такое поведение флоатов даёт интересные эффекты:

    Эффект прохождения сквозь блоки. Проявляется, когда зафлоаченный элемент выше, чем несколько последующих за ним блоков.
    Эффект выпадания из родителя или схлопывания родителя. Проявляется тогда, когда все дочерние блоки в родителе зафлоачены.
     В этом случае родитель схлопывается по высоте, как будто в нём нет содержимого, а блоки выпадают из него.


-------простейшая сетка на флоуте, хедер-футер-две колонки

    <!DOCTYPE html>
    <html lang="ru">
        <head>
           <title>Простейшая сетка, финал</title>
           <meta charset="utf-8">
           <link href="//fonts.googleapis.com/css?family=PT+Sans:400&subset=cyrillic" rel="stylesheet" type="text/css">
        </head>
        <body>
            <div class="wrapper">
                <div class="header">Хедер</div>
                <div class="content-container clearfix">
                    <div class="sidebar">
                        <p>Для нужного нам эффекта мы дадим основному блоку левый margin, чтобы он ужался направо, а боковую панель заfloat'им.</p>
                    </div>
                    <div class="content">
                        <p>У этого способа есть один очень серьезный недостаток. Обратите внимание, что в исходном HTML блок "sidebar" идет до блока
                        "content" с основным содержимым. Не нужно думать, что так сделано случайно. Так сделано специально, потому что иначе этот самый способ
                        с наложением колонки поверх margin'а не работал бы.</p>
                    </div>
                </div>
                <div class="footer">Футер</div>
            </div>
        </body>
    </html>

    body {
        margin: 0;
        padding: 0;
        font-family: "PT Sans", sans-serif;
    }

    .wrapper {
        width: 450px;
        margin: 0 auto;
        box-shadow: 0 0 2px #cccccc;
    }

    .header,
    .footer {
        padding: 10px;
        background: #ecf0f1;
    }

    .sidebar {
        float: left;
        width: 150px;
        min-height: 150px;
        padding: 10px;
        color: white;
        background: rgba(46, 204, 113, 0.8);
    }

    .content {
        margin-left: 170px;
        min-height: 100px;
        padding: 10px;
        color: white;
        background: #3498db;
    }

    .clearfix::after {
        display: table;
        content: "";
        clear: both;;
    }


----------более сложная сетка, две колонки в хедере, три в контенте + футер

    <!DOCTYPE html>
    <html lang="ru">
        <head>
           <title>Последняя сетка завершена</title>
           <meta charset="utf-8">
           <link href="//fonts.googleapis.com/css?family=PT+Sans:400&subset=cyrillic" rel="stylesheet" type="text/css">
        </head>
        <body>
            <div class="header">
                <div class="layout-positioner">
                    <div class="layout-column-1 layout-column">
                        <div class="logo hidden">
                            <img width="140" src="/themes/htmlacademy/img/logo.png">
                            <p>Научитесь создавать современные веб-интерфейсы, оттачивайте своё мастерство, станьте настоящим профессионалом.</p>
                        </div>
                    </div>
                    <div class="layout-column-2 layout-column">
                        <ul class="menu hidden">
                            <li>Курсы</li>
                            <li>Интенсив</li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="features">
                <div class="layout-positioner">
                    <div class="layout-column">
                        <div class="feature hidden">
                            Вы научитесь создавать современные веб-интерфейсы, работать с живым кодом, использовать новейшие технологии.
                        </div>
                    </div>
                    <div class="layout-column">
                        <div class="feature hidden">
                            Минимум скучной теории и максимум практических упражнений, решение реальных задач и настоящие испытания.
                        </div>
                    </div>
                    <div class="layout-column">
                        <div class="feature hidden">
                            Интересные, наглядные и затягивающие курсы, интерактивные интерфейсы, достижения — всё для обучения с удовольствием.
                        </div>
                    </div>
                </div>
            </div>
            <div class="footer">
                <div class="layout-positioner">
                    <div class="footer-logo hidden">
                        <img width="140" src="/themes/htmlacademy/img/logo.png">
                    </div>
                </div>
            </div>
        </body>
    </html>

    body {
        min-width: 500px;
        margin: 0;
        padding: 0;
        font-family: "PT Sans", sans-serif;
        font-size: 14px;
    }

    .clearfix::after {
        display: table;
        content: "";
        clear: both;
    }

    .layout-positioner {
        width: 430px;
        margin: 0 auto;

    }

    .layout-positioner::after {
        display: table;
        content: "";
        clear: both;
    }

    .header {
        margin-bottom: 10px;
        color: white;
        background: #34495e;
    }

    .header .layout-column {
        min-height: 50px;

    }

    .header .layout-column-1 {
        float: left;
        width: 280px;
    }

    .header .layout-column-2 {
        float: right;
        width: 130px;
    }

    .features {
        margin-bottom: 10px;
    }

    .features .layout-column {
        float: left;
        margin-right: 20px;
        width: 130px;
        min-height: 100px;
        background: rgba(236, 240, 241, 0.9);
    }

    .features .layout-column:last-child {
        margin-right: 0;
    }

    .footer {
        min-height: 50px;
        color: white;
        background: #34495e;
    }

    /* Стили содержания */
    .hidden {
        display: block;
    }

    .logo {
        padding: 10px;
    }

    .logo p {
        margin: 0;
    }

    .menu {
        margin: 0;
        padding: 10px;
        list-style: none;
    }

    .menu li {
        margin-bottom: 5px;
        padding: 5px;
        text-align: center;
        background: #2c3e50;
        border-radius: 5px;
    }

    .feature {
        padding: 10px;
        text-align: center;
    }

    .footer-logo {
        padding: 10px;
    }


--------------------------------блочная верстка

    Существует несколько способов записи свойства padding.

    padding: 10px;
    padding: 5px 10px;
    padding: 5px 10px 15px;
    padding: 5px 10px 15px 20px;
    Одинаковые отступы со всех сторон.

    Отступы сверху и снизу 5px, справа и слева 10px.

    Отступ сверху 5px, слева и справа 10px, снизу 15px.

    Разные отступы со всех сторон, в порядке верхний, правый, нижний, левый.

    Также можно задавать отступы для разных сторон с помощью свойств padding-left, padding-right, padding-top, padding-bottom.


----ширина полей формы

    Проблему с шириной тянущихся полей решить сложно. Идеальным вариантом было бы изменение алгоритма расчета ширины элемента,
    чтобы свойство width задавало не ширину содержания, а общую ширину.

    К счастью, такая возможность была добавлена в CSS3 с помощью свойства box-sizing, которое уже поддерживается большинством современных браузеров.

    Это свойство имеет два значения:

    content-box — значение по умолчанию, соответствует стандартной блочной модели.
    border-box — изменяет режим расчета ширины элемента на описанный выше.



    Значение none свойства display используется очень часто. С его помощью можно скрыть элемент, как будто его и не было.
    Скрытый элемент не отображается и не занимает места на странице.

    Данное свойство применяется при создании выпадающих меню, динамических галерей, переключающихся вкладок и много где еще.

    Есть еще одно CSS-свойство, которое используется для сокрытия элементов. Это свойство visibility со значением hidden.
    Оно «прячет» элемент — он становится невидимым, но занимает место на странице.




--------------------------------установка бэкграунда одним параметром

    Фон элемента можно задавать с помощью отдельных свойств: background-color, background-image и т.д. Получается довольно громоздкая запись.

    Также задать фон можно с помощью сокращенного свойства background, в котором через пробел перечисляются его компоненты:

    background: [bc] [bi] [br] [bp] [ba];
    /* Обозначения:
    [bc] — background-color
    [bi] — background-image
    [br] — background-repeat
    [bp] — background-position
    [ba] — background-attachment
    */
    Если какой-то компонент не указан, то берется значение по умолчанию. Ниже примеры.

    background: #e74c3c;
    background: url("img.png") no-repeat;
    background: url("img.png") 10px 20px;
    В первом примере просто задан цвет фона.

    Во втором примере задано не повторяющееся фоновое изображение, а также по умолчанию прозрачный цвет фона, расположение в левом верхнем углу.

    В третьем примере задано фоновое изображение и его расположение, а также по умолчанию прозрачный цвет фона и режим повторения во все стороны.



--------------------------------выбор по атрибутам

    Существуют селекторы, которые позволяют выбирать элементы по любым атрибутам.

    Чаще всего такие селекторы используются при работе с формами, так как поля форм имеют атрибут type с разными значениями.

    Селекторы атрибутов записываются с использованием квадратных скобок: элемент[атрибут]. Примеры селекторов:

    1. input[checked] { ... }
    2. input[type="text"] { ... }
    Первый селектор выберет поля формы, у которых есть атрибут checked, второй селектор выберет поля формы, у которых атрибут type имеет значение text.


--------------------------------дети по номеру

    1. li:nth-child(2) { ... }
    2. li:nth-child(4) { ... }
    3. li:nth-child(2n) { ... }
    Первый селектор выберет второй элемент списка, второй селектор — четвёртый элемент списка, третий селектор — все чётные элементы.


--------------------------------Дочерние селекторы
    Потомком называются любые элементы, расположенные внутри родительского элемента. А дочерними элементами называются ближайшие потомки. Взгляните на пример:

    <ul>
      <li><span>...</span></li>
      <li><span>...</span></li>
    </ul>
    По отношению к <ul> <li> являются дочерними элементами и потомками, а <span> — потомки, но не дочерние элементы.

    Контекстные селекторы влияют на всех потомков, что не всегда удобно. Иногда необходимо задать стили только для дочерних элементов.
    Особенно это полезно при работе с многоуровневыми списками.

    Для этого существует дочерний селектор, в котором используется символ >. Например: ul > li или ul > li > span.

    В этом задании вы разберётесь, чем отличаются контекстные и дочерние селекторы.

    Исправьте таблицу результатов:

    Цель 1 Нижние рамки должны остаться только у элементов списка первого уровня.
    Цель 2 Выделение жирным должно остаться только у фамилий.

    <!DOCTYPE html>
    <html>
        <head>
            <meta charset="utf-8">
            <title>Дочерние селекторы</title>
            <link rel="stylesheet" href="/assets/course7/course-3.css">
        </head>
        <body>
            <h1>Сводка</h1>
            <ul class="places">
                <li>
                    <span>Устюгов</span>
                    <ul>
                        <li><span>0 штрафных</span></li>
                        <li><span>0 запасных</span></li>
                    </ul>
                </li>
                <li>
                    <span>Черезов</span>
                    <ul>
                        <li><span>0 штрафных</span></li>
                        <li><span>2 запасных</span></li>
                    </ul>
                </li>
                <li>
                    <span>Бьёрндален</span>
                    <ul>
                        <li><span>1 штрафной</span></li>
                        <li><span>4 запасных</span></li>
                    </ul>
                </li>
            </ul>
        </body>
    </html>

    .places > li {
        border-bottom: 2px solid #cccccc;
    }

    .places > li > span {
        font-weight: bold;
    }


--------------------------------Контекстные и соседние селекторы

    <!DOCTYPE html>
    <html>
        <head>
            <meta charset="utf-8">
            <title>Контекстные и соседние селекторы</title>
            <link rel="stylesheet" href="/assets/course7/course-2.css">
        </head>
        <body>
            <div class="shooter-1">
                <ul class="target">
                    <li>1</li>
                    <li>2</li>
                    <li class="third">3</li>
                    <li>4</li>
                    <li>5</li>
                </ul>
            </div>
            <div class="shooter-2">
                <ul class="target">
                    <li class="first">1</li>
                    <li>2</li>
                    <li class="third">3</li>
                    <li>4</li>
                    <li>5</li>
                </ul>
            </div>
        </body>
    </html>

    .shooter-1 li {
        background-color: white;
    }

    .shooter-2 li {
        background-color: white;
    }

    .shooter-1 .third + li {
        background-color: red;
    }

    .shooter-2 .first + li {
        background-color: red;
    }

    .shooter-2 .third + li {
        background-color: yellow;
    }


---------------------------------более сложные селекторы

    Псевдокласс :not(селектор) является отрицающим селектором. С его помощью можно выбрать элементы, которые НЕ содержат указанный селектор:

    li:not(:last-child) { }
    Этот селектор выберет все теги <li>, НЕ являющиеся последними в их родителе.

    Псевдокласс :not похож на оператор ! в программировании:

    if (!selector) { ... }
    В качестве селектора могут указываться псевдоклассы, теги, идентификаторы, классы и селекторы атрибутов. Нельзя использовать двойной псевдокласс
    :not, то есть конструкция :not(:not(...)) не сработает.

    Также в комбинации с :not не применяются:

    объединение селекторов: например, li:not(.heart.jack) – некорректный селектор;
    псевдоэлементы: li:not(::after) – неправильная запись (подробнее о псевдоэлементах рассказано далее в курсе);
    селекторы-потомки, групповые селекторы или комбинации: например, нельзя писать li:not(a span) или li:not(a + span).
--------
    Отрицающий селектор :not, как и любые другие селекторы, можно комбинировать с другими. Например:

    li:not(:first-child):not(:last-child) { }
    Выберет все теги <li>, которые НЕ являются первыми и последними в их родителе.

    Объединять можно неограниченное количество селекторов.


-----------
    В первом курсе про селекторы мы уже рассматривали псевдокласс :nth-child, сейчас посмотрим на :nth-last-child.

    Псевдокласс :nth-last-child используется для добавления стиля к элементам на основе нумерации в дереве элементов.
    В отличие от псевдокласса :nth-child, отсчет ведется не от первого элемента, а от последнего. Вот и все различия.

        <!DOCTYPE html>
    <html lang="ru">
        <head>
            <meta charset="utf-8">
            <title>Псевдокласс :nth-last-child</title>
            <link rel="stylesheet" href="/assets/course57/course.css">
        </head>
        <body>
            <ul class="cards">
                <li class="ace heart"></li>
                <li class="king diamond"></li>
                <li class="queen club"></li>
                <li class="jack spade"></li>
                <li class="king club"></li>
                <li class="ace spade"></li>
                <li class="jack heart"></li>
            </ul>
            <ul class="cards">
                <li class="jack diamond"></li>
                <li class="ace club"></li>
                <li class="king spade"></li>
                <li class="queen heart"></li>
                <li class="queen spade"></li>
                <li class="king heart"></li>
                <li class="ace diamond"></li>
            </ul>
            <ul class="cards">
                <li class="queen spade"></li>
                <li class="king heart"></li>
                <li class="king club"></li>
                <li class="ace spade"></li>
                <li class="jack heart"></li>
                <li class="queen diamond"></li>
                <li class="ace diamond"></li>
            </ul>
            <ul class="cards">
                <li class="queen spade"></li>
                <li class="ace spade"></li>
                <li class="jack heart"></li>
                <li class="ace spade"></li>
                <li class="ace heart"></li>
                <li class="queen diamond"></li>
                <li class="ace diamond"></li>
            </ul>
        </body>
    </html>

        .cards:nth-last-child(2) li {
        background-color: #ff3300;
    }

    .cards li:nth-last-child(2) {
        background-color: #339933;
    }

    .cards:nth-last-child(2) li:nth-last-child(2) {
        background-color: #0099ff;
    }

----------
    Псевдокласс :first-of-typeочень похож на :first-child. Он выбирает первый дочерний элемент родителя, только с учетом типа элементов.

    Например, в этом задании перед списками с картами есть блок с текстом. У списков и у блока с текстом общий родитель — body.

    <body>
    <div class="paper"> … </div>
    <ul class="cards"> … </ul>
    <ul class="cards"> … </ul>
    </body>
    Сравним две записи:

    ul:first-child {
    background: #ffffee;
    }

    ul:first-of-type {
    background: #ffffee;
    }
    Верхний селектор выбирает первый дочерний элемент в родителе, причем этот элемент должен быть ul.
    В нашем случае не выберется ничего, потому что первым дочерним элементом body является div.

    Нижний селектор выбирает первый ul среди всех дочерних ul в своем родителе. В нашем случае будет выбрана первая строка с картами.

    <!DOCTYPE html>
    <html lang="ru">
      <head>
          <meta charset="utf-8">
          <title>Псевдокласс :first-of-type</title>
          <link rel="stylesheet" href="/assets/course57/course.css">
      </head>
      <body>
          <div class="paper">
              <h1>Как раскладывать пасьянс?</h1>
              <p>Как хотите, так и раскладывайте.</p>
          </div>
          <ul class="cards">
              <li class="ace heart"></li>
              <li class="king diamond"></li>
              <li class="queen club"></li>
              <li class="jack spade"></li>
              <li class="king club"></li>
              <li class="ace spade"></li>
              <li class="jack heart"></li>
          </ul>
          <ul class="cards">
              <li class="jack diamond"></li>
              <li class="ace club"></li>
              <li class="king spade"></li>
              <li class="queen heart"></li>
              <li class="queen spade"></li>
              <li class="king heart"></li>
              <li class="ace diamond"></li>
          </ul>
          <ul class="cards">
              <li class="queen spade"></li>
              <li class="king heart"></li>
              <li class="king club"></li>
              <li class="ace spade"></li>
              <li class="jack heart"></li>
              <li class="queen diamond"></li>
              <li class="ace diamond"></li>
          </ul>
          <ul class="cards">
              <li class="queen spade"></li>
              <li class="ace spade"></li>
              <li class="jack heart"></li>
              <li class="ace spade"></li>
              <li class="ace heart"></li>
              <li class="queen diamond"></li>
              <li class="ace diamond"></li>
          </ul>
      </body>
    </html>


    li:first-of-type {
        background: #ff3300;
    }

    ul:first-of-type li {
        background: #339933;
    }

    ul:first-of-type li:first-of-type {
        background: #0099ff;
    }

    В предыдущем задании мы рассмотрели псевдокласс :first-of-type.

    Псевдокласс :last-of-type работает аналогично, только выбирает последний дочерний элемент родителя с учетом типа.


    Псевдокласс :nth-of-type работает почти так же, как и :nth-child. Разница заключается в том, что он учитывает тип элемента.

    ul:nth-of-type(2n) li {
    background: #ff3300;
    }


    ul:nth-of-type(3) li:nth-of-type(3) {
        background: #339933;
    }

    ul:nth-of-type(1) li:nth-of-type(odd) {
        background: #0099ff;
    }


    Псевдокласс :only-child пригодится, когда нужно прописать индивидуальные стили для элемента, который является единственным
    дочерним элементом внутри родительского контейнера.

    Пример:

    li:only-child {
        ...
    }
    Сработает, когда этот <li> в списке единственный.

    Cелектор :only-child эквивалентен селектору elem:last-child:first-child.



    Псевдокласс :only-of-type работает почти так же, как и :only-child. Отличие состоит в том, что он учитывает тип элемента.


    Псевдоэлемент before позволяет с помощью CSS добавить псевдотег внутрь другого элемента и оформить его. Cодержимое псевдотега задаётся с помощью свойства content.


    Псевдоэлемент after аналогичен before. Отличие заключается в том, что он добавляет псевдотег не в начало, а в конец элемента.

    Вы можете задавать псевдоэлементам любые CSS-свойства. Можно менять тип элемента, задавать ему позиционирование, отступы, фон и так далее.

    Этими возможностями особенно часто пользуются при создании различных декоративных эффектов. Это очень удобно.

    Во-первых, не нужно добавлять лишний тег под каждую очередную мелкую иконку.

    Во-вторых, можно управлять этими иконками/декоративными элементами только с помощью CSS, что открывает огромный простор для создания интересных динамических эффектов.




    Псевдоэлемент first-line задает стиль первой строки форматированного текста. Длина этой строки зависит от многих факторов,
    таких как используемый шрифт, размер окна браузера, ширина блока, языка и т.д. В правилах стиля допустимо использовать только свойства,
    относящиеся к шрифту, изменению цвета текста и фона.

    Пример использования:

    p::first-line { }
    Аналогично псевдоэлемент first-letter определяет стиль первого символа в тексте элемента, к которому добавляется.
    К этому псевдоэлементу могут применяться только стилевые свойства, связанные со свойствами шрифта, полями, отступами, границами, цветом и фоном.

    Пример использования:

    p::first-letter { }



------------ cелекторы 3

    Запись вида [foo^="bar"] выберет все элементы, у которых значение атрибута foo начинается с подстроки bar.

    Представьте, что у вас есть три класса для задания колонок разной ширины, например: column-1, column-2 и column-3.

    У этих классов часть свойств повторяется, а разной является только ширина. Чтобы не дублировать CSS-код,
    вы можете вынести общие свойства колонок в правило с селектором [class^="column-"], а в остальных правилах задать только ширину



    Селектор вида [foo$="bar"] выбирает все элементы, значение атрибута foo которых оканчивается строкой bar.



    Следующий вариант записи [foo*="bar"]

    Будут выбраны все элементы, у которых значение атрибута foo содержит подстроку bar на любой позиции

    Среди трёх элементов:

    <p class="person-name"></p>
    <div class="some-person-info"></div>
    <span class="date-person"></span>
    селектор [class*="person"] выберет все.

    Обратите внимание, что селектор чувствителен к регистру.



    Следующая запись: [foo~="bar"].

    Такой селектор выберет все элементы, у которых значение атрибута foo содержит слово bar.

    Входить должно именно слово, а не просто подстрока. То есть вхождение bar должно содержать с обеих сторон разделители: пробелы или начало/конец строки.



    Для обращения к элементам, которые являются доступными на сайте (не заблокированными), можно использовать псевдокласс :enabled.
    Заблокированными считаются элементы форм, у которых установлен атрибут disabled.



    Селектор :read-write выберет все поля доступные для редактирования

    Селектор :read-only выберет все поля доступные только для чтения


    Мы уже разбирали, что при помощи специального атрибута required можно отметить поля, обязательные для заполнения
    Используя селектор :required можно задать отдельные стили для этих полей


    Помимо :required существует селектор :optional, выполняющий обратное действие. То есть выберутся все элементы, у которых НЕ указан атрибут required

    При помощи селектора :checked можно обратиться ко всем элементам input с типами checkbox или radio, которые являются выбранными (отмеченными)



    При помощи разных типов полей (email, url и др.) или специфических настроек (pattern, min/max и др.) можно указать браузеру,
    какие именно данные мы ожидаем от пользователя в том или ином поле.

    Селектор :valid выберет все элементы, у которых введенное значение удовлетворяет требованиям.

    А селектор :invalid соответственно выберет элементы, у которых введенное значение некорректно



    В курсе, посвященном Формам и HTML5 мы разбирали специальный тип поля для ввода числовых значений <input type="number">.
    У этого поля можно определить максимальное и минимальное значение при помощи атрибутов max и min соответственно.

    Селектор :in-range выбирает все элементы, значение которых попадает в указанный диапазон.

    А селектор :out-of-range выбирает все элементы, значение которых НЕ попадает в указанный диапазон.


    Благодаря селектору :checked, с помощью чистого CSS можно создавать очень много интересных эффектов, так как мы можем не просто выбирать отмеченные поля форм,
     но и влиять с помощью этих полей на другие элементы.
    Для этого нам нужно комбинировать :checked и ~, который позволяет выбрать все элементы, идущие за отмеченным полем. Пример:
    input:checked ~ .item {
      color: red;
      }
    Такое CSS-правило задаст красный цвет, всем элементам с классом item, расположенным после отмеченного поля.

    Получается, что мы можем с помощью чекбоксов или радиобаттонов
    управлять внешним видом других элементов. С помощью этого приёма, например, делают переключающиеся вкладки, которые работают без JavaScript.

    #father:checked ~ .cat-in-box[title^="Отец"]:before {
        display:none;    }
    #rudolf:checked ~ .cat-in-box[title$="Рудольф"]:before {
        display: none;    }
    #snow:checked ~ .cat-in-box[title$="Снежок"]:before {
        display: none;    }

          <!DOCTYPE html>
    <html lang="ru">
        <head>
            <title>Испытание: UI-кит для формы</title>
            <meta charset="utf-8">
            <link rel="stylesheet" href="/assets/course58/exam.css">
        </head>
        <body>
            <header class="page-header">Форма личных данных</header>
            <main>
                <form action="/echo" method="post">
                    <fieldset>
                        <legend>Примеры полей</legend>
                        <div class="half-width">
                            <label>Радио-переключатели</label>
                            <input id="radio-1" name="radio" type="radio" checked>
                            <label for="radio-1">Активный</label>
                            <input id="radio-2" name="radio" type="radio">
                            <label for="radio-2">Неактивный</label>
                            <input id="radio-3" name="radio" type="radio" disabled>
                            <label for="radio-3">Заблокированный</label>
                        </div>
                        <div class="half-width">
                            <label>Чекбоксы</label>
                            <input id="checkbox-1" type="checkbox" checked>
                            <label for="checkbox-1">Активный</label>
                            <input id="checkbox-2" type="checkbox">
                            <label for="checkbox-2">Неактивный</label>
                            <input id="checkbox-3" type="checkbox" disabled>
                            <label for="checkbox-3">Заблокированный</label>
                        </div>
                        <label>Текстовые поля</label>
                        <input type="text" value="Обычное">
                        <input type="text" value="Обязательное" required>
                        <input type="text" value="Заблокированное" disabled>
                        <input type="text" value="Неверные данные" pattern="[0-9]{8}">
                    </fieldset>
                </form>
            </main>
            <footer class="page-footer"></footer>
        </body>
    </html>

      body {
      width: 550px;
    }

    form {
      width: 400px;
      margin: 0 auto;
      padding: 20px;
      border-radius: 10px;
      background-color: #ffffff;
      box-shadow: 0 0 10px #cccccc;
    }

    fieldset {
      padding: 10px;
      border: 1px solid #34495e;
      border-radius: 5px;
    }

    fieldset legend {
      color: #34495e;
    }

    .half-width {
      display: inline-block;
      width: 50%;
      margin-right: -4px;
    }

    label {
      display: block;
      margin-bottom: 5px;
      margin-top: 10px;
    }

    input[type="radio"],
    input[type="checkbox"]{
      display: none;
    }

    input[type="radio"] + label,
    input[type="checkbox"] + label{
      vertical-align: middle;
      color: #7f8c8d;
    }

    input[type="checkbox"] + label:before,
    input[type="radio"] + label:before{
      content: "";
      display: inline-block;
      width: 7px;
      height: 7px;
      margin-right: 8px;
      vertical-align: middle;
      border: 3px solid #ffffff;
      box-shadow: 0 0 0 3px #bdc3c7;
    }

    input[type="radio"] + label:before {
      border-radius: 50%;
    }

    input[type="radio"]:checked + label:before,
    input[type="checkbox"]:checked + label:before{
      background: #1abc9c;
      box-shadow: 0 0 0 3px #1abc9c;
    }

    input[type="radio"]:checked + label,
    input[type="checkbox"]:checked + label{
      color: #1abc9c;
    }

    input[type="radio"]:disabled + label:before,
    input[type="checkbox"]:disabled + label:before{
      box-shadow: 0 0 0 3px #ecf0f1;
    }

    input[type="radio"]:disabled + label,
    input[type="checkbox"]:disabled + label{
      color: #ecf0f1;
    }

    input[type="text"] {
      width: 95%;
      height: 24px;
      margin-bottom: 10px;
      padding: 2px 5px;
      color: #000;
      border: 2px solid #bdc3c7;
      border-radius: 5px;
      vertical-align: middle;
    }

    input[type="text"]:required {
      border-color: #e74c3c;
    }

    input[type="text"]:disabled {
      color: #bdc3c7;
      background: #f5f5f5;
      border-color: #ecf0f1;
    }

    input[type="text"]:invalid {
      color: #c0392b;
      background: #f2a097;
      border-color: #e74c3c;
    }


--------------------------------наследование и каскадирование

    Когда для одного и того же элемента есть несколько CSS-правил с одинаковыми свойствами, браузер использует понятия приоритетов и
    специфичности, чтобы выбрать значение свойства из нескольких возможных. Упрощённо, можно сказать что:

    -CSS-правила в значении атрибута style самые приоритетные,
    -за ними идёт селектор с id,
    -затем селектор с классом,
    -затем селектор с именем тега.

    К наследуемым свойствам относятся в первую очередь свойства, определяющие параметры отображения текста:

    font-size, font-family, font-style, font-weight, color, text-align, text-transform,
    text-indent, line-height, letter-spacing, word-spacing, white-space, direction и т. д.

    Также к наследуемым свойствам относятся list-style, cursor, visibility, border-collapse и некоторые другие. Но они используются значительно реже.

    Весь список наследуемых свойств смотрите в стандарте CSS. Значение yes в колонке Inherited?.
    Эти свойства можно и нужно задавать через предков, следуя семантике документа.

    Например, параметры текста зачастую не меняются в пределах отдельных блоков страницы: меню, основного содержания,
     информационных панелей. Поэтому общие параметры текста (цвет, размер, гарнитура) обычно указывают в стилях самих блоков.


     Все остальные относятся к ненаследуемым. Это параметры позиционирования, размеров, отступов, фона, рамок и т. д.

    А именно: background, border, padding, margin, width, height, position и др.

    Весь список ненаследуемых свойств смотрите в стандарте CSS. Значение no в колонке Inherited?.
    Не наследуются они из соображений здравого смысла. Например: если для какого-либо блока установлен внутренний отступ,
    автоматически выставлять такой же отступ каждому вложенному элементу нет никакой надобности. Эти параметры чаще всего уникальны для каждого отдельного блока.

    Для каждого свойства может быть задано значение inherit.

    Оно означает, что данное свойство принимает такое же значение, как и у родительского элемента. Значение inherit
    может быть использовано для усиления наследуемых значений, а также в свойствах, которые обычно не наследуются.

    Запись выглядит следующим образом:

    p {
        background: inherit;
    }
    В данном случае у тегов p свойство background будет таким же, как и у их родительских тегов.

    --------
    Чуть более сложный пример. Тот же HTML:

    <p class="red blue">Синий или красный?</p>
    Немного другой CSS:

    p.blue {
        color: blue;
    }

    .red {
        color: red;
    }
    В этом случае текст абзаца будет синим. Происходит это потому, что селектор p.blue более специфичный, чем селектор .red.

    Простое объяснение специфичности звучит так:

    Чем меньшее количество элементов потенциально может выбрать селектор, тем он специфичнее.
    В нашем примере селектор .red выберет все теги с нужным классом, а селектор p.blue выберет только абзацы с нужным классом.


--------------------------------все типы форм

    <!DOCTYPE html>
    <html>
        <head>
            <meta charset="utf-8">
            <title>Испытание: редактирование профиля</title>
        </head>
        <body>
            <h1>Профиль</h1>

            <form action="https://echo.htmlacademy.ru" method="post">
                <label>Ваш пол:
                <input type='radio' name='sex' value='m'>Мужской</input>
                <input type='radio' name='sex' value='f'>Женский</input>
                </label> <br>
               <label> Месяц и год рождения:</label><br>
                    <select name="mob">
                        <option value="light">Январь</option>

                    </select>
                    <select name="yob">
                        <option value="light">1990</option>

                    </select><br>
                    <label>Знакомые технологии:</label><br>
                    <select multiple size="4" name="tech">
                        <option>HTML</option>
                        <option selected>CSS</option>
                        <option>JavaScript</option>
                        <option>Node.js</option>
                    </select><br>

                <label>Фото:</label><input type='file' name='foto'></input> <br>
                <input type='submit' value='Сохранить'></input>
            </form>
        </body>
    </html>

--------------------------------оформление цитат

    В HTML существует несколько тегов для обозначения цитат:

    <blockquote> предназначен для выделения длинных цитат, которые могут состоять из нескольких абзацев. Тег выделяет цитату как отдельный блок текста с отступами.
    <q> предназначен для выделения коротких цитат в предложениях. Текст внутри этого тега автоматически обрамляется кавычками.
    <cite> используется для того, чтобы выделить источник цитаты, название произведения или автора цитаты.



--------------------------------вертикальное меню

    <head>
        <meta charset="utf-8">
        <title>Испытание: вертикальное меню</title>
    </head>
    <body>
        <ul class="main-menu">
        <li><a>Курсы</a></li>
        <li class='active'><a>Демонстрации</a></li>
        <li><a>Участники</a></li>
        <li><a>Достижения</a></li>
        <li><a>Профиль</a></li>
        </ul>
    </body>
    </html>


    html,
    body {
        margin: 0;
        padding: 0;
    }

    body {
        width: 280px;
        min-height: 280px;
        padding: 10px;
        font-family: "Arial", sans-serif;
        font-size: 14px;
        line-height: 1.4;
        background: #ecf0f1;
    }

    .main-menu {
        width: 200px;
        padding: 0px;
        margin: 10px 0px 0px 0px;
        text-decoration: none;
    }

    .main-menu .active a {
        background-color: #1abc9c;
        border-bottom: solid 2px #2ecc71;
    }

    .main-menu a {
        padding: 10px 10px 10px 15px;
        border-bottom: solid 2px #2c3e50;
        color: #ffffff;
        background-color: #2980b9;
        display: block;
    }
